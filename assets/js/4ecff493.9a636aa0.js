"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9638],{3905:(e,a,n)=>{n.d(a,{Zo:()=>g,kt:()=>h});var r=n(7294);function t(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function s(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?s(Object(n),!0).forEach((function(a){t(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function p(e,a){if(null==e)return{};var n,r,t=function(e,a){if(null==e)return{};var n,r,t={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],a.indexOf(n)>=0||(t[n]=e[n]);return t}(e,a);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(t[n]=e[n])}return t}var o=r.createContext({}),d=function(e){var a=r.useContext(o),n=a;return e&&(n="function"==typeof e?e(a):i(i({},a),e)),n},g=function(e){var a=d(e.components);return r.createElement(o.Provider,{value:a},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},l=r.forwardRef((function(e,a){var n=e.components,t=e.mdxType,s=e.originalType,o=e.parentName,g=p(e,["components","mdxType","originalType","parentName"]),c=d(n),l=t,h=c["".concat(o,".").concat(l)]||c[l]||u[l]||s;return n?r.createElement(h,i(i({ref:a},g),{},{components:n})):r.createElement(h,i({ref:a},g))}));function h(e,a){var n=arguments,t=a&&a.mdxType;if("string"==typeof e||t){var s=n.length,i=new Array(s);i[0]=l;var p={};for(var o in a)hasOwnProperty.call(a,o)&&(p[o]=a[o]);p.originalType=e,p[c]="string"==typeof e?e:t,i[1]=p;for(var d=2;d<s;d++)i[d]=n[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}l.displayName="MDXCreateElement"},8282:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>o,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>p,toc:()=>d});var r=n(7462),t=(n(7294),n(3905));const s={sidebar_position:3},i="Subgraph Upgrade Pre-syncing",p={unversionedId:"graphcast/radios/subgraph-radio/subgraph-upgrade-presyncing",id:"graphcast/radios/subgraph-radio/subgraph-upgrade-presyncing",title:"Subgraph Upgrade Pre-syncing",description:"The Subgraph Upgrade Pre-sync feature provides a way for Subgraph Developers to signal when they plan on releasing a new subgraph version, thereby allowing Indexers to start syncing the subgraph in advance. Subgraph Developers can use the Graphcast CLI to send a message to all Indexers, interested in the given subgraph.",source:"@site/docs/graphcast/radios/subgraph-radio/subgraph-upgrade-presyncing.md",sourceDirName:"graphcast/radios/subgraph-radio",slug:"/graphcast/radios/subgraph-radio/subgraph-upgrade-presyncing",permalink:"/graphcast/radios/subgraph-radio/subgraph-upgrade-presyncing",draft:!1,editUrl:"https://github.com/graphops/docs/edit/main/docs/graphcast/radios/subgraph-radio/subgraph-upgrade-presyncing.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"gnSidebar",previous:{title:"POI Cross-checking",permalink:"/graphcast/radios/subgraph-radio/poi-cross-checking"},next:{title:"Notifications and Monitoring",permalink:"/graphcast/radios/subgraph-radio/monitoring"}},o={},d=[{value:"As an Indexer running Subgraph Radio",id:"as-an-indexer-running-subgraph-radio",level:2},{value:"Rate Limits",id:"rate-limits",level:3},{value:"As a Subgraph Developer",id:"as-a-subgraph-developer",level:2},{value:"Send an Upgrade Intent Message",id:"send-an-upgrade-intent-message",level:3},{value:"Check Indexing Status",id:"check-indexing-status",level:3},{value:"Sequence Diagram",id:"sequence-diagram",level:2}],g={toc:d},c="wrapper";function u(e){let{components:a,...s}=e;return(0,t.kt)(c,(0,r.Z)({},g,s,{components:a,mdxType:"MDXLayout"}),(0,t.kt)("h1",{id:"subgraph-upgrade-pre-syncing"},"Subgraph Upgrade Pre-syncing"),(0,t.kt)("p",null,"The Subgraph Upgrade Pre-sync feature provides a way for Subgraph Developers to signal when they plan on releasing a new subgraph version, thereby allowing Indexers to start syncing the subgraph in advance. Subgraph Developers can use the ",(0,t.kt)("a",{parentName:"p",href:"https://docs.graphops.xyz/graphcast/radios/graphcast-cli"},"Graphcast CLI")," to send a message to all Indexers, interested in the given subgraph."),(0,t.kt)("p",null,(0,t.kt)("img",{alt:"Upgrade Presyncing",src:n(4221).Z,width:"960",height:"540"})),(0,t.kt)("h2",{id:"as-an-indexer-running-subgraph-radio"},"As an Indexer running Subgraph Radio"),(0,t.kt)("p",null,"As long as there is a valid configuration for ",(0,t.kt)("inlineCode",{parentName:"p"},"AUTO_UPGRADE")," and ",(0,t.kt)("inlineCode",{parentName:"p"},"INDEXER_MANAGEMENT_SERVER_ENDPOINT")," (see ",(0,t.kt)("a",{parentName:"p",href:"advanced-configuration"},"Advanced Configuration"),"), Subgraph Radio will process Upgrade Intent Messages and automatically begin offchain syncing new Subgraph Deployments."),(0,t.kt)("h3",{id:"rate-limits"},"Rate Limits"),(0,t.kt)("p",null,"In order to prevent spam, Subgraph Radio implements a rate limit on Upgrade Intent Messages. By default, Subgraph Radio will permit one upgrade for an existing Subgraph Deployment per day."),(0,t.kt)("h2",{id:"as-a-subgraph-developer"},"As a Subgraph Developer"),(0,t.kt)("h3",{id:"send-an-upgrade-intent-message"},"Send an Upgrade Intent Message"),(0,t.kt)("p",null,"Refer to the ",(0,t.kt)("a",{parentName:"p",href:"https://docs.graphops.xyz/graphcast/radios/graphcast-cli#usage"},"usage section")," of Graphcast CLI to learn more about different ways to send a ",(0,t.kt)("inlineCode",{parentName:"p"},"UpgradeIntentMessage"),", as well as the different configurations options available."),(0,t.kt)("p",null,"Example:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-bash"},'docker run ghcr.io/graphops/graphcast-cli \\\n  # pass the address for subgraph deployer\n  --graph-account "0xe9a1cabd57700b17945fd81feefba82340d9568f" \\\n  # pass the pk for the subgraph deployer\n  --private-key "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef" \\\n  # specify we want to send an upgrade presync message\n  upgrade-presync \\\n  # specify the subgraph ID\n  --subgraph-id "CnJMdCkW3pr619gsJVtUPAWxspALPdCMw6o7obzYBNp3" \\\n  # specify the new subgraph deployment hash\n  --new-hash "QmVVfLWowm1xkqc41vcygKNwFUvpsDSMbHdHghxmDVmH9x"\n')),(0,t.kt)("p",null,"This is what the final log should look like after successfully sending the message:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-bash"},'INFO graphcast_cli::operator::operation: Sent message, msg_id: "0x126c76b7a5e9a30b3834807e0e02f9858191d153746ae7aebdef90bd4bae9b7a"\n    at src/operator/operation.rs:37\n')),(0,t.kt)("h3",{id:"check-indexing-status"},"Check Indexing Status"),(0,t.kt)("p",null,"After sending an ",(0,t.kt)("inlineCode",{parentName:"p"},"UpgradeIntentMessage"),", a Subgraph Developer can periodically check the indexing status of the new subgraph deployment using the public API of the Indexers who actively allocate on the current version of the subgraph."),(0,t.kt)("p",null,"Same arguments here can be used as the argument for ",(0,t.kt)("inlineCode",{parentName:"p"},"UpgradeIntentMessage"),". However, ",(0,t.kt)("em",{parentName:"p"},"gossiping")," is not involved in this operation and the queries are made through deterministic queries."),(0,t.kt)("p",null,"Command for querying for the indexing status:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-bash"},'docker run ghcr.io/graphops/graphcast-cli \\\n    --private-key "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef" \\\n    --graph-account "0xe9a1cabd57700b17945fd81feefba82340d9568f" \\\n    indexing-status --new-hash "QmVVfLWowm1xkqc41vcygKNwFUvpsDSMbHdHghxmDVmH9x" \\\n    --subgraph-id "CnJMdCkW3pr619gsJVtUPAWxspALPdCMw6o7obzYBNp3"\n')),(0,t.kt)("h2",{id:"sequence-diagram"},"Sequence Diagram"),(0,t.kt)("mermaid",{value:"sequenceDiagram\nactor DR as Subgraph A Owner\nparticipant GN as Graphcast Network\nparticipant SIR as Subscribed Indexer Radios\nparticipant IMS as Indexer Management Server\nparticipant ISE as Indexer Status Endpoint\n\nNote over DR: Deploy new Subgraph A version 1\nDR--\x3e>GN: Send upgrade intent message (A-0)\nGN--\x3e>SIR: Broadcast upgrade intent message (A-0)\nactivate SIR\nSIR->>SIR: Trusted source identity verification\ndeactivate SIR\n\nopt Sender identity as Subgraph owner verified\n  opt Auto sync management\n    SIR->>IMS: POST request to initiate off-chain syncing A-1\n    IMS->>SIR: Response from Graph Node\n      SIR->>SIR: Update topics\n      SIR--\x3e>GN: Subscribe to A-1\n  end\n\n  opt Notifications\n    activate SIR\n    SIR->>SIR: Notify events to human\n    deactivate SIR\n  end\nend\n\nDR--\x3eSIR: Switch service from A-0 to A1, deprecate A-0\nSIR--\x3e>GN: Unsubscribe to A-0\n\nloop Periodic Indexing Status Check\n  DR--\x3e>ISE: Request Indexing Status\n  ISE--\x3e>DR: Send Indexing Status\nend"}))}u.isMDXComponent=!0},4221:(e,a,n)=>{n.d(a,{Z:()=>r});const r=n.p+"assets/images/graphcast-upgrade-presyncing-3e6c8e03a0f87ef555e088d427f0cee3.svg"}}]);