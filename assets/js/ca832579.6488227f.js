"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4091],{9977:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>h,contentTitle:()=>o,default:()=>l,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var n=t(4848),s=t(8453);const i={sidebar_position:4},o="Notifications and Monitoring",r={id:"graphcast/radios/subgraph-radio/monitoring",title:"Notifications and Monitoring",description:"Notifications",source:"@site/docs/graphcast/radios/subgraph-radio/monitoring.md",sourceDirName:"graphcast/radios/subgraph-radio",slug:"/graphcast/radios/subgraph-radio/monitoring",permalink:"/graphcast/radios/subgraph-radio/monitoring",draft:!1,unlisted:!1,editUrl:"https://github.com/graphops/docs/edit/main/docs/graphcast/radios/subgraph-radio/monitoring.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"gnSidebar",previous:{title:"Subgraph Upgrade Pre-syncing",permalink:"/graphcast/radios/subgraph-radio/subgraph-upgrade-presyncing"},next:{title:"Advanced Configuration",permalink:"/graphcast/radios/subgraph-radio/advanced-configuration"}},h={},d=[{value:"Notifications",id:"notifications",level:2},{value:"Notification modes",id:"notification-modes",level:3},{value:"Prometheus &amp; Grafana",id:"prometheus--grafana",level:2},{value:"Setting up the Grafana dashboard",id:"setting-up-the-grafana-dashboard",level:3},{value:"Reading the Grafana dashboard",id:"reading-the-grafana-dashboard",level:3},{value:"POI Comparison Overview",id:"poi-comparison-overview",level:4},{value:"Message stats",id:"message-stats",level:4},{value:"Number of Gossiping Indexers per Subgraph",id:"number-of-gossiping-indexers-per-subgraph",level:4},{value:"POI Comparison Results",id:"poi-comparison-results",level:4},{value:"Function Call Stats",id:"function-call-stats",level:4},{value:"Number of diverged subgraphs",id:"number-of-diverged-subgraphs",level:4},{value:"Locally tracked Public POIs",id:"locally-tracked-public-pois",level:4}];function c(e){const a={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(a.header,{children:(0,n.jsx)(a.h1,{id:"notifications-and-monitoring",children:"Notifications and Monitoring"})}),"\n",(0,n.jsx)(a.h2,{id:"notifications",children:"Notifications"}),"\n",(0,n.jsx)(a.p,{children:"If the Radio operator has set up a Slack, Discord and/or Telegram bot integration and the Radio finds a POI mismatch, it sends alerts to the designated channels. The operator can also inspect the logs to see if the Radio is functioning properly, if it's sending and receiving messages, if it's comparing normalised POIs, if there is a found POI mismatch, etc."}),"\n",(0,n.jsx)(a.h3,{id:"notification-modes",children:"Notification modes"}),"\n",(0,n.jsx)(a.p,{children:"Subgraph Radio supports three modes of notification, based on the user's preference for how often they'd like to get notified, and what data the notifications contain:"}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.code,{children:"live"})," - the Radio sends a notification as soon as it finds a divergence, providing the Subgraph deployment and the block."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.code,{children:"periodic-update"})," - the Radio sends a notification on a specified interval (default is 24 hours) containing any updates to comparison results that have happened since the previous notification (the notification message format is the same as the one using live mode). If there are no updates it will not send a notification."]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.code,{children:"periodic-report"})," - the Radio sends a notification on a specified interval (default is 24 hours) with a summary of total subgraphs being cross-checked, number of matched subgraphs, number of diverged subgraphs, and a list of the divergent subgraphs and the blocks where the divergence was caught."]}),"\n"]}),"\n",(0,n.jsxs)(a.p,{children:["The default notification mode if there's Slack/Discord/Telegram integration in place is ",(0,n.jsx)(a.code,{children:"live"}),"."]}),"\n",(0,n.jsxs)(a.p,{children:["The notification mode can be toggled using the ",(0,n.jsx)(a.code,{children:"NOTIFICATION_MODE"})," and ",(0,n.jsx)(a.code,{children:"NOTIFICATION_INTERVAL"})," configuration variables."]}),"\n",(0,n.jsxs)(a.p,{children:["See more information on how to configure notifications, as well as how to set up Slack, Discord and Telegram in the ",(0,n.jsx)(a.a,{href:"advanced-configuration",children:"advanced configuration section"}),"."]}),"\n",(0,n.jsx)(a.h2,{id:"prometheus--grafana",children:"Prometheus & Grafana"}),"\n",(0,n.jsxs)(a.p,{children:["The Subgraph Radio exposes metrics that can then be scraped by a Prometheus server and displayed in Grafana. In order to use them you have to have a local Prometheus server running and scraping metrics on the provided port. You can specify the metrics host and port by using the environment variables ",(0,n.jsx)(a.code,{children:"METRICS_PORT"})," and ",(0,n.jsx)(a.code,{children:"METRICS_HOST"}),"."]}),"\n",(0,n.jsx)(a.h3,{id:"setting-up-the-grafana-dashboard",children:"Setting up the Grafana dashboard"}),"\n",(0,n.jsx)(a.p,{children:"The Subgraph Radio Grafana dashboard is included by default in Stakesquid's docker-compose stack. If you're not using the stack, below is a walk-through of how you can set it up."}),"\n",(0,n.jsxs)(a.p,{children:["There is a ",(0,n.jsx)(a.a,{href:"https://github.com/graphops/subgraph-radio/blob/dev/grafana.json",children:"Grafana dashboard config JSON file"})," provided in the repo, which you can import and use to visualise the metrics in Grafana. When importing the dashboard, it will require you to specify two data sources - a Prometheus one and a GraphQL one. For Prometheus you should select the Prometheus instance that you've set up to scrape metrics from Subgraph Radio's metrics host and port. For GraphQL, you'd need to install the ",(0,n.jsx)(a.a,{href:"https://grafana.com/grafana/plugins/fifemon-graphql-datasource/?tab=installation",children:"GraphQL data source plugin"}),", if you don't have it already installed. Then you need to create a new GraphQL data srouce that points to the GraphQL API of the Radio's integrated HTTP server. For instance, if you've set ",(0,n.jsx)(a.code,{children:"SERVER_HOST"})," to",(0,n.jsx)(a.code,{children:" 0.0.0.0"})," and ",(0,n.jsx)(a.code,{children:"SERVER_PORT"})," to ",(0,n.jsx)(a.code,{children:"3012"}),", your GraphQL data source would need to point at ",(0,n.jsx)(a.code,{children:"http://0.0.0.0:3012/api/v1/graphql"}),". You can learn more about the HTTP server in the next section."]}),"\n",(0,n.jsx)(a.h3,{id:"reading-the-grafana-dashboard",children:"Reading the Grafana dashboard"}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.img,{alt:"Grafana Dashboard",src:t(9812).A+"",width:"2800",height:"1592"})}),"\n",(0,n.jsx)(a.p,{children:"When the Subgraph Radio Grafana dashboard has been set up, it offers 6 panels:"}),"\n",(0,n.jsx)(a.h4,{id:"poi-comparison-overview",children:"POI Comparison Overview"}),"\n",(0,n.jsx)(a.p,{children:"At a glance, you can see the number of matching and diverging subgraphs. These two gauges update to reflect the results continiously after each comparison. The reason these are gauges and not counters is because a subgraph's comparison result can change between POI comparison events, for instance you might have a diverging public POI for a given subgraph on block X, but then at block Y it could be matching with the consensus public POI, in that case is would change groups, the number of divergent subgraphs would decrement and the number of matching subgraphs would increment."}),"\n",(0,n.jsx)(a.h4,{id:"message-stats",children:"Message stats"}),"\n",(0,n.jsx)(a.p,{children:"This includes the validated messages per minute, as well as the total cached messages in the store."}),"\n",(0,n.jsx)(a.h4,{id:"number-of-gossiping-indexers-per-subgraph",children:"Number of Gossiping Indexers per Subgraph"}),"\n",(0,n.jsx)(a.p,{children:"This panel shows how many Indexers are actively sending public POIs for the subgraphs that you're interested in. This view can be filtered by a specific subgraph."}),"\n",(0,n.jsx)(a.h4,{id:"poi-comparison-results",children:"POI Comparison Results"}),"\n",(0,n.jsx)(a.p,{children:"This is the most insightful and important panel. The data in it is coming directly from the HTTP server's GraphQL endpoint. It shows the most recent comparison results for each subgraph that is being actively cross-checked, as well as the block for which that comparison happened."}),"\n",(0,n.jsxs)(a.p,{children:["The Count Ratio shows the ratio of unique senders that have attested to a public POI for that subgraph on that block. For instance ",(0,n.jsx)(a.code,{children:"3:1:1*"})," means that there are three distinct public POIs that were compared. It also means there are four Indexers attesting to public POIs that is different that the locally generated public POI, three of them attest to the same POI and the third Indexer attests to a different one, but none of those two POIs match the locally generated one. If it's ",(0,n.jsx)(a.code,{children:"3*:1"})," it means that the local POI matches with the most often attested POI (highest sender count), meaning that the local Indexer is in that group of three Indexers, and there is one other Indexer who has sent a different POI. If it's ",(0,n.jsx)(a.code,{children:"4*"})," it means that there are four Indexers attesting to a given POI and all four POIs are the same (the local one included). ",(0,n.jsxs)(a.strong,{children:["The count that has a ",(0,n.jsx)(a.code,{children:"*"})," sign is where the local attestation is."]})]}),"\n",(0,n.jsxs)(a.p,{children:["Another possible ratio value is ",(0,n.jsx)(a.code,{children:"3:0*"}),", the ",(0,n.jsx)(a.code,{children:"0*"})," here represents that there is no local public POI, generated for this subgraph on this block (this might happen due to a lot of reasons, one of them being that the subgraph isn't fully synced)."]}),"\n",(0,n.jsxs)(a.p,{children:["The Stake Ratio is similar to the Count Ratio, but POIs are grouped by stake, so ",(0,n.jsx)(a.code,{children:"11686531*"})," means that that is the combined stake backing the public POI for that subgraph on that block (the local Indexer stake is included) where as for example ",(0,n.jsx)(a.code,{children:"44141361*:651361"})," would mean that there are two distinct POIs and hence two different sender groups, and these two stake values are the aggregated stake values behind each of those POIs. The ",(0,n.jsx)(a.code,{children:"*"})," on the first one means that the local Indexer's stake is attesting to the same public POIs and the local stake is included in that value. Similar to the Count Ratio, if there's a ",(0,n.jsx)(a.code,{children:"0*"}),", for instance - ",(0,n.jsx)(a.code,{children:"44141361:0*"}),", it means that there is no local public POI, generated for this subgraph on this block (therefore there is no attesting stake from the local Indexer)."]}),"\n",(0,n.jsx)(a.h4,{id:"function-call-stats",children:"Function Call Stats"}),"\n",(0,n.jsx)(a.p,{children:"Shows insights into the frequency of different functions running in the Radio, it helps convey a sense of how often/how many times certain events have happened, like POI comparison, processing a validated message, sending a message, and more."}),"\n",(0,n.jsx)(a.h4,{id:"number-of-diverged-subgraphs",children:"Number of diverged subgraphs"}),"\n",(0,n.jsx)(a.p,{children:"Count of diverged subgraphs and how it's changed over time."}),"\n",(0,n.jsx)(a.h4,{id:"locally-tracked-public-pois",children:"Locally tracked Public POIs"}),"\n",(0,n.jsx)(a.p,{children:"Number of locally generated public POIs for all of the subgraphs that are actively being cross-checked."})]})}function l(e={}){const{wrapper:a}={...(0,s.R)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},9812:(e,a,t)=>{t.d(a,{A:()=>n});const n=t.p+"assets/images/graphcast-grafana-dashboard-4bdfaf0d4121420e6810682b3e27c8f7.png"},8453:(e,a,t)=>{t.d(a,{R:()=>o,x:()=>r});var n=t(6540);const s={},i=n.createContext(s);function o(e){const a=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function r(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(i.Provider,{value:a},e.children)}}}]);