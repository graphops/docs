"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5207],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=l(n),h=r,m=d["".concat(c,".").concat(h)]||d[h]||u[h]||i;return n?a.createElement(m,s(s({ref:t},p),{},{components:n})):a.createElement(m,s({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=h;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o[d]="string"==typeof e?e:r,s[1]=o;for(var l=2;l<i;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3138:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:2},s="\u2699\ufe0f Design Principles",o={unversionedId:"graphcast/design-principles",id:"graphcast/design-principles",title:"\u2699\ufe0f Design Principles",description:"There are two main components of Graphcast",source:"@site/docs/graphcast/design-principles.md",sourceDirName:"graphcast",slug:"/graphcast/design-principles",permalink:"/graphcast/design-principles",draft:!1,editUrl:"https://github.com/graphops/docs/edit/main/docs/graphcast/design-principles.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"gnSidebar",previous:{title:"\ud83d\udc4b Introduction",permalink:"/graphcast/intro"},next:{title:"\ud83d\udc4b Introduction",permalink:"/graphcast/sdk/intro"}},c={},l=[{value:"The Graphcast SDK",id:"the-graphcast-sdk",level:2},{value:"Radios",id:"radios",level:2}],p={toc:l},d="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"\ufe0f-design-principles"},"\u2699\ufe0f Design Principles"),(0,r.kt)("p",null,"There are two main components of Graphcast"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The Graphcast SDK: The base layer SDK which interfaces with The Graph stack and the Waku network. This includes interactions with an Ethereum client, a Graph node client, a client for the Indexer management server, the Network subgraph and the Registry subgraph)."),(0,r.kt)("li",{parentName:"ul"},"Radios: Highly customizable gossip applications, built with the help of the Graphcast SDK, which define the specific message formats and logic around constructing and handling the messages. They are the nodes communicating in the Graphcast Network.")),(0,r.kt)("h2",{id:"the-graphcast-sdk"},"The Graphcast SDK"),(0,r.kt)("p",null,"The SDK is the base layer which is used to abstract all the necessary components of each Radio away from the user. That includes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Establishes a connection to Graphcast via a ",(0,r.kt)("a",{parentName:"li",href:"https://waku.org/"},"Waku")," Gossip node, providing an interface for subscribing to specific topics and broadcasting messages across the network."),(0,r.kt)("li",{parentName:"ul"},"Interactions with an Ethereum node, a Graph node and a client for the Indexer management server."),(0,r.kt)("li",{parentName:"ul"},"Queries to Network and Registry subgraphs."),(0,r.kt)("li",{parentName:"ul"},"Checks message validity for past message injections, nonexistent blocks and expired timestamps. It also guarantees that messages are signed by an authorised operator address of an active on-chain Indexer (this can be used as a basis for a reputation system)."),(0,r.kt)("li",{parentName:"ul"},"Supports a flexible and customizable configuration of the Graphcast gossip agent, enabling specification of network settings, peer discovery mechanisms, message encoding formats, and more. For detailed instructions on configuring Graphcast to suit your needs, refer to the configuration guide."),(0,r.kt)("li",{parentName:"ul"},"Topics in Graphcast represent different categories or subjects of information. Nodes can dynamically subscribe to specific topics to receive messages related to those topics. Topics enable efficient message routing and dissemination within the network."),(0,r.kt)("li",{parentName:"ul"},"Provides comprehensive message handling structure to ensure that messages are reliably transmitted, received, and processed within the network. ")),(0,r.kt)("h2",{id:"radios"},"Radios"),(0,r.kt)("p",null,"General Radio components"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Supports Radio for specific use cases."),(0,r.kt)("li",{parentName:"ul"},"Controls topic subscriptions dynamically for interested topics. "),(0,r.kt)("li",{parentName:"ul"},"Provides radio type definition used to verify the integrity and authenticity of messages exchanged within the network."),(0,r.kt)("li",{parentName:"ul"},"Collects Radio-specific information and incorporates it into Graphcast messages along with other relevant metadata."),(0,r.kt)("li",{parentName:"ul"},"Observes and handles relevant messages received from peers."),(0,r.kt)("li",{parentName:"ul"},"Provides performance metrics, logs, and API services.")),(0,r.kt)("p",null,"Our first example Radio is built for real-time cross-checking of Indexer Proof of Indexing attestations (POIs). Indexers must generate valid POIs to earn indexing rewards. Indexers find it beneficial to alert each other on the health status of subgraphs in community discussions. To alleviate the manual workload, the POI Radio:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Defines message types and topics"),(0,r.kt)("li",{parentName:"ul"},"Collects POIs from the Graph node and sends them inside of Graphcast messages along with other useful metadata"),(0,r.kt)("li",{parentName:"ul"},"Observes relevant messages and aggregates POIs sent from other Indexers, in order to compare ",(0,r.kt)("em",{parentName:"li"},"local")," POIs to ",(0,r.kt)("em",{parentName:"li"},"remote")," POIs"),(0,r.kt)("li",{parentName:"ul"},"Monitors the network for conflicts and takes certain actions if needed, for instance Indexers can configure an alert system to send messages to a custom channel in their Slack workspace (support for Discord and email notifications coming soon).")))}u.isMDXComponent=!0}}]);