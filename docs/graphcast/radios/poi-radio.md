---
sidebar_position: 1
---

# ðŸ“Ÿ POI Radio

The source code for the POI Radio is available [on GitHub](https://github.com/graphops/poi-radio) and Docker builds are automatically published as [GitHub Packages](https://github.com/graphops/poi-radio/pkgs/container/poi-radio). POI Radio is also published as a Crate [on Crates.io](https://crates.io/crates/poi-radio).

## Introduction

The POI Radio is an optional component of the Graph Protocol Indexer Stack that leverages the Graphcast Network to cross-check subgraph data integrity with other participating Indexers.

In order for an Indexer to earn indexing rewards from the Protocol, valid Proofs of Indexing (POIs) must be posted on-chain regularly, proving that the Indexer has the correct data. Posting an invalid POI exposes the Indexer to the liability of a [Dispute](https://thegraph.com/docs/en/network/indexing/#what-are-disputes-and-where-can-i-view-them) and being slashed by the Protocol. This Radio provides Indexers peace of mind that their POIs are being continuously cross-checked against other participating Indexers. In the event that there is a POI discrepancy, the Radio acts as an early warning system, notifying the Indexer within minutes of the discrepancy occuring.

All POIs that are generated by the Radio are normalized, meaning they are hashed with a `0x0` Indexer Address and can be compared between Indexers, all without being valid POIs that could be submitted on-chain for rewards. The Radio will group and weight all normalized POIs by the aggregate stake in GRT that is attesting to each. The normalized POI with the largest aggregate attesting stake is considered canonical and will be used for comparisons with your local Indexer POIs.

For security reasons, POI Radio needs an independent Graphcast ID linked to your Indexer account to operate. Your Graphcast ID is an Ethereum account that has been authorized to sign POI attestations on behalf of your Indexer. Follow instructions for registering your Graphcast ID below.

## Getting Started

### Registering your Graphcast ID

The Graphcast Registry contract maps Graphcast IDs to Indexers in the Graph Protocol. You'll need to register a Graphcast ID that is authorized to sign messages on behalf of your Indexer in order to use Graphcast.

Here is a brief overview of the accounts you'll be interacting with:

| Account Name | Description |
| - | - |
| Indexer Account | The existing account associated with your Graph Protocol Indexer. This may be a Token Lock Contract address, or a multisig or EOA address. |
| Indexer Operator Account | An account you have registered as an Operator for your Indexer. You can use the Operator account that you pass to `indexer-agent`. |
| Graphcast ID Account | A new account that you will create that is used by Graphcast Radio instances to sign messages on behalf of your Indexer. |

You'll need to use a registered [Indexer Operator](https://thegraph.com/docs/en/network/indexing/#stake-in-the-protocol) account for your Indexer to register a Graphcast ID.

```mermaid
flowchart LR
    subgraph Graphcast Registry
    A[Graphcast ID] -->|points to| B(Indexer Account)
    end 
    O[Indexer Operator Account] -->|registers| A
```

:::tip
You can register multiple Operators for your Indexer in parallel. If you would prefer not to import the Operator account that you use with `indexer-agent` into your wallet in order to register your Graphcast ID, you can generate and register a dedicated operator account for this purpose. After you have registered your Graphcast ID, you can deregister the dedicated operator if you desire.
:::

1. [Generate a new Ethereum account](https://iancoleman.io/bip39/) to act as your Graphcast ID, keeping the details safe. Be sure to select the Ethereum network, and save the mnemonic, as well as the address and private key for the first account. This is your Graphcast ID.
2. Import your Indexer Operator private key into your wallet (e.g. MetaMask or Frame) in order to send a transaction to register your Graphcast ID.
3. Navigate to Etherscan ([Mainnet registry](https://etherscan.io/address/0x89f97698d6006f25570cd2e31737d3d22aedcbcf#writeProxyContract), [Goerli registry](https://goerli.etherscan.io/address/0x26ebbA649FAa7b56FDB8DE9Ea17aF3504B76BFA0#writeProxyContract)) in order to interact with the Graphcast Registry contract and register your Graphcast ID.
4. Call `setGraphcastIDFor(indexer_address, graphcast_id)`, passing in your Indexer Address and Graphcast ID. Neither address should be your Indexer Operator address that is being used to sign the transaction.
5. Submit your transaction and wait for it to be included in a block.

:::info
Each Graphcast ID can be associated with a single Indexer. To revoke a Graphcast ID for your Indexer, call `setGraphcastIDFor(indexer_address, graphcast_id)` with a Graphcast ID of `0x0` using a registered Indexer Operator Account.
:::

Great, you now have a Graphcast ID that is authorized to sign messages on behalf of your Indexer. You can now use this Graphcast ID to run a POI Radio instance.

### Basic Configuration

The POI Radio is configured using environment variables. You will need to prepare the following environment variables:

| Name                                  | Description and examples                                                                                  |
| ------------------------------------- | ---------------------------------------------------------------------------------------- |
| `PRIVATE_KEY`                         | Private key for your Graphcast ID.<br/>Example: `0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef`                       |
| `GRAPH_NODE_STATUS_ENDPOINT`          | URL to a Graph Node Indexing Status endpoint.<br/>Example: `http://index-node:8030/graphql` |
| `REGISTRY_SUBGRAPH`                   | URL to the Graphcast Registry subgraph for your network.<br/>Mainnet: `https://thegraph.com/hosted-service/subgraph/hopeyen/graphcast-registry-mainnet`<br/>Goerli: `https://thegraph.com/hosted-service/subgraph/hopeyen/graphcast-registry-goerli`        |
| `NETWORK_SUBGRAPH`                    | URL to the Graph Network subgraph<br/>Mainnet: `https://gateway.thegraph.com/network`<br/>Goerli: `https://gateway.testnet.thegraph.com/network`|
| `GRAPHCAST_NETWORK`                   | The Graphcast Messaging fleet and pubsub namespace to use.<br/>Mainnet: `mainnet`<br/>Goerli: `testnet`|

### Run with Docker

1. Pull the POI Radio image

```bash
docker pull ghcr.io/graphops/poi-radio:latest
```

2. Run the image, providing the required environment variables. Here's a sample mainnet configuration:

```bash
docker run \
    -e GRAPHCAST_NETWORK="mainnet" \
    -e REGISTRY_SUBGRAPH="https://api.thegraph.com/subgraphs/name/hopeyen/graphcast-registry-mainnet" \
    -e NETWORK_SUBGRAPH="https://gateway.thegraph.com/network" \
    -e PRIVATE_KEY="GRAPHCAST_ID_PRIVATE_KEY" \
    -e GRAPH_NODE_STATUS_ENDPOINT="http://graph-node:8030/graphql" \
    -e RUST_LOG="warn,hyper=warn,graphcast_sdk=info,poi_radio=info" \
    ghcr.io/graphops/poi-radio:latest
```

### (or) Run with docker-compose

You can append this service definition to your `docker-compose` manifest and customise the definitions:

```yaml
services:
  # ... your other service definitions
  poi-radio:
    image: ghcr.io/graphops/poi-radio:latest
    container_name: poi-radio
    restart: unless-stopped
    environment:
      GRAPHCAST_NETWORK: "mainnet"
      REGISTRY_SUBGRAPH: "https://api.thegraph.com/subgraphs/name/hopeyen/graphcast-registry-mainnet"
      NETWORK_SUBGRAPH: "https://gateway.thegraph.com/network"
      PRIVATE_KEY: "GRAPHCAST_ID_PRIVATE_KEY"
      GRAPH_NODE_STATUS_ENDPOINT: "http://graph-node:8030/graphql"
      RUST_LOG: "warn,hyper=warn,graphcast_sdk=info,poi_radio=info"
    logging:
      driver: local
```

### (or) Run using a pre-built binary

We also provide pre-built binaries for Ubuntu and MacOS, which you can find in the `Assets` section on each release in the [releases page](https://github.com/graphops/poi-radio/releases) on Github. Simply download the binary, make it executable (`chmod a+x ./poi-radio-{TAG}-{SYSTEM}`) and then run it (using `./poi-radio-{TAG}-{SYSTEM}`).

## Advanced Configuration

In the configuration table below is the full list of environment variables you can set, along with example values.


See [Basic Configuration](#basic-configuration) above. The following environment variables are optional:

| Name                                  | Description and examples                                                                                  |
| ------------------------------------- | ---------------------------------------------------------------------------------------- |
| `COLLECT_MESSAGE_DURATION` (Optional) | Seconds that the POI Radio will wait to collect remote POI attestations before making a comparison with the local POI. Example: `120` for 2 minutes. |
| `WAKU_HOST` (Optional)                | Interface onto which to bind the bundled Waku node. Example: `127.0.0.1` |
| `WAKU_PORT` (Optional)                | P2P port on which the bundled Waku node will operate. Example: `60000` |
| `WAKU_NODE_KEY` (Optional)            | Static Waku Node Key. |
| `BOOT_NODE_ADDRESSES` (Optional)      | Peer addresses to use as Waku boot nodes. Example: `"addr1, addr2, addr3"` |
| `SLACK_TOKEN` (Optional)              | Slack Token to use for notifications. Example: `xoxp-0123456789-0123456789-0123456789-0123456789` |
| `SLACK_WEBHOOK` (Optional)            | Slack Webhook to use for notifications. Example: `https://hooks.slack.com/services/<ID>/<ID>/<TOKEN>` |
| `RUST_LOG` (Optional)                 | Rust tracing configuration. Example: `graphcast_sdk=debug,poi_radio=debug`, defaults to `info` for everything |

`SLACK_TOKEN` and `SLACK_WEBHOOK` are used for POI divergence notifications in a Slack channel.

`WAKU_HOST` and `WAKU_PORT` specify where the bundled Waku node runs. If you want to run multiple Radios, or multiple instances of the same Radio, you should run them on different ports.

If you want to customize the log level, you can toggle `RUST_LOG` environment variable. Here's an example configuration to get more verbose logging:

```
RUST_LOG="warn,hyper=warn,graphcast_sdk=debug,poi_radio=debug"
```

## Monitoring the Radio

If the Radio operator has set up a Slack Bot integration and the Radio finds a POI mismatch, it sends alerts to the designated channel. The operator can also inspect the logs to see if the Radio is functioning properly, if it's sending and receiving messages, if it's comparing normalised POIs, if there is a found POI mismatch, etc.

Support for Prometheus metrics and Grafana dashboards is coming soon!

## How it works

### Fetching active allocations

The POI Radio is responsible for reading active allocations of the Radio operator's corresponding Indexer. It periodically polls the Graph Node for new blocks on all relevant networks and constructs Graphcast topics on each allocation identified by subgraph deployment IPFS hash.

:::tip
The relevant networks are those corresponding to the subgraphs that have active allocations.
:::

The Radio fetches new active allocations at a regular interval to ensure that it is processing the latest information. Chainheads for these networks are updated with data from the Graph Node, and the Radio ensures that it is always using the latest chainhead when processing messages.


```mermaid
sequenceDiagram
    participant Network Subgraph
    participant Graph Node
    participant POI Radio
    participant Graphcast Network
    actor Human
    loop Track allocated deployments
        POI Radio->>+Network Subgraph: Get latest allocated deployments
        Network Subgraph->>-POI Radio: Return allocated deployments
        loop Monitor allocated deployments and chain heads
            POI Radio->>+Graph Node: Get indexing statuses for allocated deployments
            Graph Node->>-POI Radio: Return matching indexing statuses
            activate POI Radio
            POI Radio->>POI Radio: Update chain heads
            deactivate POI Radio
            loop For each deployment that we are tracking
                opt If deployment reached trigger block is healthy
                    POI Radio->>+Graph Node: Fetch POI for deployment
                    Graph Node->>-POI Radio: Normalized POI
                    activate POI Radio
                    POI Radio->>POI Radio: Generate signed POI Attestation
                    deactivate POI Radio
                    POI Radio-->>Graphcast Network: Broadcast POI Attestation to Graphcast Network
                end
                opt If stored remote attestations and collect message duration passed
                    activate POI Radio
                    POI Radio->>POI Radio: Compute consensus remote POI
                    deactivate POI Radio
                    opt If local POI mismatches consensus remote POI
                        POI Radio-->>Human: Send POI divergence warning notification
                    end
                end
            end
        end
    end
```

### Gathering and comparing normalised POIs

At a given interval, the Radio fetches the normalised POI for each deployment. This interval is defined in blocks different for each network.

It then saves those nPOIs in an in-memory map. These nPOIs are referred to as _local_ POIs since they are generated by the Radio. As other Indexers running the Radio start doing the same, messages start propagating through the network. The Radio handles each message and adds the POI from it in another in-memory map. These POIs are referred to as _remote_ POIs since they are received from other network participants.

The messages include a nonce (UNIX timestamp), block number, signature (used to derive the sender's on-chain Indexer address) and network. Before saving an entry to the map, the Radio operator verifies through the Graph network subgraph for the sender's on-chain identity and amount of tokens staked, which is used during comparisons later on.


```mermaid
flowchart LR
    a[Fetch deployment status] --> b[If healthy & synced]
    b -->|No| eee{End}
    b -->|Yes| c[If reached trigger block]
    c -->|No| eee
    c -->|Yes| d[Fetch POI for deployment]
    d -->|Broadcast| n(Graphcast\nNetwork)
    n -->|Receive remote POI| o[Other Indexers]
    n --> x{End}
```

At another interval, the Radio compares the local POIs with the collected remote ones. The remote POIs are sorted so that for each subgraph (on each block), the POI that is backed by the most on-chain stake is selected. This means that the combined stake of all Indexers that attested to it is considered, not just the highest staking Indexer. The top POI is then compared with the local POI for that subgraph at that block to determine consensus.

After a successful comparison, the attestations that have been checked are removed from the store.


```mermaid
flowchart LR
    q[Fetch deployment status] --> g[Has collection window expired?]
    g -->|Yes| t[Compute consensus remote POI]
    g -->|No| p{End}
    c -->|Aggregate| t
    a[Receive POI attestations] --> b[Has collection window expired?]
    b -->|Yes| eee{End}
    b -->|No| c[Store remote attestation\nfor deployment]
    t --> l[Does local POI match remote consensus POI?]
    l -->|No| i[Send notification]
    l -->|Yes| d{End}
```

## Developing the POI Radio

#### Building the image using the Dockerfile locally

If you want to make any changes to the POI Radio codebase, you can use this option.

##### Prerequisites

1. Clone this repo and `cd` into it
2. Create a `.env` file that includes at least the required environment variables. To see the full list of environment variables you can provide, check out the [Configuration](#configuration) section.

##### Running the POI Radio inside a Docker container

```bash
docker-compose up -d
```

### Building POI Radio locally

To have full control over the POI Radio code and run it directly on your machine (without Docker) you can use this option.

#### Prerequisites

1. Clone this repo and `cd` into it
2. Make sure you have the following installed:

- [Rust](https://www.rust-lang.org/tools/install)
- [Go](https://go.dev/doc/install)
- Build tools (e.g. the `build-essentials` package for Debian-based Linux distributions or [Xcode Command Line Tools](https://mac.install.guide/commandlinetools/index.html) for MacOS)
- C compiler (e.g. the `clang` package for Debian-based Linux distribution or [Xcode Command Line Tools](https://mac.install.guide/commandlinetools/index.html) for MacOS)
- OpenSSL (e.g. the `libssl-dev` package for Debian-based Linux distribution or `openssl` for MacOS)
- PostreSQL libraries and headers (e.g. the `libpq-dev` package for Debian-based Linux distribution or `postgresql` for MacOS)

3. You have **Graph Node** syncing your indexer's on-chain allocations.
4. You have created a `.env` file that includes at least the required environment variables. To see the full list of environment variables you can provide, check out the [Configuration](#configuration) section.

#### Running the POI Radio natively

```
cargo run
```
