---
sidebar_position: 1
---

# ðŸ“Ÿ POI Radio

The source code for the POI Radio is available [on GitHub](https://github.com/graphops/poi-radio) and Docker builds are automatically published as [GitHub Packages](https://github.com/graphops/poi-radio/pkgs/container/poi-radio). POI Radio is also published as a Crate [on Crates.io](https://crates.io/crates/poi-radio).

## Introduction

The POI Radio is an optional component of the Graph Protocol Indexer Stack that leverages the Graphcast Network to cross-check subgraph data integrity with other participating Indexers.

In order for an Indexer to earn indexing rewards from the Protocol, valid Proofs of Indexing (POIs) must be posted on-chain regularly, proving that the Indexer has the correct data. Posting an invalid POI exposes the Indexer to the liability of a [Dispute](https://thegraph.com/docs/en/network/indexing/#what-are-disputes-and-where-can-i-view-them) and being slashed by the Protocol. This Radio provides Indexers peace of mind that their POIs are being continuously cross-checked against other participating Indexers. In the event that there is a POI discrepancy, the Radio acts as an early warning system, notifying the Indexer within minutes of the discrepancy occuring.

All POIs that are generated by the Radio are normalized, meaning they are hashed with a `0x0` Indexer Address and can be compared between Indexers, all without being valid POIs that could be submitted on-chain for rewards. The Radio will group and weight all normalized POIs by the aggregate stake in GRT that is attesting to each. The normalized POI with the largest aggregate attesting stake is considered canonical and will be used for comparisons with your local Indexer POIs.

For security reasons, POI Radio needs an independent Graphcast ID linked to your Indexer account to operate. Your Graphcast ID is an Ethereum account that has been authorized to sign POI attestations on behalf of your Indexer. Follow instructions for registering your Graphcast ID below.

## Getting Started

### Registering your Graphcast ID

The Graphcast Registry contract maps Graphcast IDs to Indexers in the Graph Protocol. You'll need to register a Graphcast ID that is authorized to sign messages on behalf of your Indexer in order to use Graphcast.

Here is a brief overview of the accounts you'll be interacting with:

| Account Name | Description |
| - | - |
| Indexer Account | The address associated with your Graph Protocol Indexer. This may be a Token Lock Contract address, or a multisig or EOA address. |
| Indexer Operator Account | An account you have registered as an Operator for your Indexer. You pass an Operator account into `indexer-agent`. You can register multiple Operators for your Indexer in parallel. |
| Graphcast ID Account | An account that is used by Graphcast Radio instances to sign messages on behalf of your Indexer. |

You'll need to use a registered [Indexer Operator](https://thegraph.com/docs/en/network/indexing/#stake-in-the-protocol) account for your Indexer to register a Graphcast ID.

:::tip
If you would prefer not to import the Operator account that you use with `indexer-agent` into your wallet in order to register your Graphcast ID, you can generate and register a dedicated operator account for this purpose. After you have registered your Graphcast ID, you can deregister the dedicated operator if you desire.
:::

1. [Generate a new Ethereum account](https://iancoleman.io/bip39/) to act as your Graphcast ID, keeping the details safe
2. Import your Indexer Operator account into your wallet
3. Navigate to Etherscan ([mainnet registry](https://etherscan.io/address/0x89f97698d6006f25570cd2e31737d3d22aedcbcf#writeProxyContract), [testnet registry](https://goerli.etherscan.io/address/0x26ebbA649FAa7b56FDB8DE9Ea17aF3504B76BFA0#writeProxyContract)) in order to interact with the Graphcast Registry contract and register your Graphcast ID
4. Call `setGraphcastIDFor(indexer_address, graphcast_id)`, passing in your Indexer Address and Graphcast ID
5. Submit your transaction and wait for it to be included in a block

:::info
Each Graphcast ID can be associated with a single Indexer. To revoke a Graphcast ID for an Indexer, call `setGraphcastIDFor(indexer_address, graphcast_id)` with a Graphcast ID of `0x0` using a registered Indexer Operator Account.
:::

### Run with Docker

1. Pull the POI Radio image

```bash
docker pull ghcr.io/graphops/poi-radio:latest
```

2. Run the image, providing the required environment variables. Here's a sample mainnet configuration:

```bash
docker run \
    -e GRAPHCAST_NETWORK="mainnet" \
    -e REGISTRY_SUBGRAPH="https://api.thegraph.com/subgraphs/name/hopeyen/graphcast-registry-mainnet" \
    -e NETWORK_SUBGRAPH="https://gateway.thegraph.com/network" \
    -e ETH_NODE="http://your-eth-node:8545" \
    -e PRIVATE_KEY="GRAPHCAST_ID_PRIVATE_KEY" \
    -e GRAPH_NODE_STATUS_ENDPOINT="http://graph-node:8030/graphql" \
    -e RUST_LOG="warn,hyper=warn,graphcast_sdk=info,poi_radio=info" \
    ghcr.io/graphops/poi-radio:latest
```

### (or) Run with docker-compose

You can append this service definition to your `docker-compose` manifest and customise the definitions:

```yaml
services:
  // ... your other service definitions

  poi-radio:
    image: ghcr.io/graphops/poi-radio:latest
    container_name: poi-radio
    restart: unless-stopped
    environment:
      GRAPHCAST_NETWORK: "mainnet"
      REGISTRY_SUBGRAPH: "https://api.thegraph.com/subgraphs/name/hopeyen/graphcast-registry-mainnet"
      NETWORK_SUBGRAPH: "https://gateway.thegraph.com/network"
      ETH_NODE: "http://your-eth-node:8545"
      PRIVATE_KEY: "GRAPHCAST_ID_PRIVATE_KEY"
      GRAPH_NODE_STATUS_ENDPOINT: "http://graph-node:8030/graphql"
      RUST_LOG: "warn,hyper=warn,graphcast_sdk=info,poi_radio=info"
    logging:
      driver: local
```

### (or) Run using a pre-built binary

We also provide pre-built binaries for Ubuntu and MacOS, which you can find in the `Assets` section on each release in the [releases page](https://github.com/graphops/poi-radio/releases) on Github. Simply download the binary, make it executable (`chmod a+x ./poi-radio-{TAG}-{SYSTEM}`) and then run it (using `./poi-radio-{TAG}-{SYSTEM}`).

## Configuration

In the configuration table below is the full list of environment variables you can set, along with example values.

### Mainnet

| Name                                  | Example                                                                                  |
| ------------------------------------- | ---------------------------------------------------------------------------------------- |
| `ETH_NODE`                            | `https://mainnet.infura.io/v3/<API_KEY>`                                                 |
| `PRIVATE_KEY`                         | `0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef`                       |
| `GRAPH_NODE_STATUS_ENDPOINT`          | `http://localhost:8030/graphql` |
| `REGISTRY_SUBGRAPH`                   | `https://thegraph.com/hosted-service/subgraph/hopeyen/graphcast-registry-mainnet`        |
| `NETWORK_SUBGRAPH`                    | `https://gateway.thegraph.com/network`                                                   |
| `GRAPHCAST_NETWORK`                   | `mainnet`                                                                                |
| `COLLECT_MESSAGE_DURATION` (Optional) | Defaults to 30 seconds                                                                   |
| `WAKU_HOST` (Optional)                | Defaults to `127.0.0.1`                                                                  |
| `WAKU_PORT` (Optional)                | Defaults to `8546`                                                                       |
| `WAKU_NODE_KEY` (Optional)            | Defaults to `None`                                                                       |
| `BOOT_NODE_ADDRESSES` (Optional)      | "addr1, addr2, addr3" (defaults to `None`)                                               |
| `SLACK_TOKEN` (Optional)              | `xoxp-0123456789-0123456789-0123456789-0123456789` (defaults to `None`)                  |
| `SLACK_WEBHOOK` (Optional)            | `https://hooks.slack.com/services/<ID>/<ID>/<TOKEN>` (defaults to `None`)                |
| `RUST_LOG` (Optional)                 | `graphcast_sdk=debug,poi_radio=debug`, defaults to `info` for everything                 |

### Testnet (Goerli)

| Name                                  | Example                                                                                  |
| ------------------------------------- | ---------------------------------------------------------------------------------------- |
| `ETH_NODE`                            | `https://goerli.infura.io/v3/<API_KEY>`                                                  |
| `PRIVATE_KEY`                         | `0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef`                       |
| `GRAPH_NODE_STATUS_ENDPOINT`          | `http://localhost:8030/graphql` or `http://host.docker.internal:8030/graphql` for Docker |
| `REGISTRY_SUBGRAPH`                   | `https://api.thegraph.com/subgraphs/name/hopeyen/graphcast-registry-goerli`              |
| `NETWORK_SUBGRAPH`                    | `https://gateway.testnet.thegraph.com/network`                                           |
| `GRAPHCAST_NETWORK`                   | `testnet`                                                                                |
| `COLLECT_MESSAGE_DURATION` (Optional) | Defaults to 30 seconds                                                                   |
| `WAKU_HOST` (Optional)                | Defaults to `127.0.0.1`                                                                  |
| `WAKU_PORT` (Optional)                | Defaults to `8546`                                                                       |
| `WAKU_NODE_KEY` (Optional)            | Defaults to `None`                                                                       |
| `BOOT_NODE_ADDRESSES` (Optional)      | "addr1, addr2, addr3" (defaults to `None`)                                               |
| `SLACK_TOKEN` (Optional)              | `xoxp-0123456789-0123456789-0123456789-0123456789` (defaults to `None`)                  |
| `SLACK_WEBHOOK` (Optional)            | `https://hooks.slack.com/services/<ID>/<ID>/<TOKEN>` (defaults to `None`)                |
| `RUST_LOG` (Optional)                 | `graphcast_sdk=debug,poi_radio=debug`, defaults to `info` for everything                 |

`SLACK_TOKEN` and `SLACK_WEBHOOK` are used for POI divergence notifications in a Slack channel.

`WAKU_HOST` and `WAKU_PORT` specify where the Graphcast node (included in all Radios) runs. If you want to run multiple Radios, or multiple instances of the same Radio, you should run them on different ports.

If you want to customize the log level, you can toggle `RUST_LOG` environment variable. Here's an example configuration to get more verbose logging:

```
RUST_LOG="warn,hyper=warn,graphcast_sdk=debug,poi_radio=debug"
```

### Monitoring the Radio

If the Radio operator has set up a Slack Bot integration and the Radio finds a POI mismatch, it sends alerts to the designated channel. The operator can also inspect the logs to see if the Radio is functioning properly, if it's sending and receiving messages, if it's comparing normalised POIs, if there is a found POI mismatch, etc.

Support for Prometheus metrics and Grafana dashboards is coming soon!

## How it works

### Fetching active allocations

The POI Radio is responsible for reading active allocations of the Radio operator's corresponding Indexer. It periodically polls the Graph Node for new blocks on all relevant networks and constructs Graphcast topics on each allocation identified by subgraph deployment IPFS hash.

:::tip
The relevant networks are those corresponding to the subgraphs that have active allocations.
:::

The Radio fetches new active allocations at a set interval (currently set to 2 minutes) to ensure that it is processing the latest information. Chainheads for these networks are updated with data from the Graph Node, and the Radio ensures that it is always using the latest chainhead when processing messages.

### Gathering and comparing normalised POIs

At a given interval, the Radio fetches the normalised POI for each deployment. This interval is defined in blocks different for each network.

:::info
These are the current intervals:

- goerli - 2 blocks
- eth mainnet - 10 blocks
- gnosis - 5 blocks
- hardhat - 5 blocks
- arbitrum one - 5 blocks
- arbitrum goerli - 5 blocks
- avalanche - 5 blocks
- polygon - 5 blocks
- celo - 5 blocks
- optimism - 5 blocks
:::

It then saves those nPOIs in an in-memory map. These nPOIs are referred to as _local_ POIs since they are generated by the Radio. As other Indexers running the Radio start doing the same, messages start propagating through the network. The Radio handles each message and adds the POI from it in another in-memory map. These POIs are referred to as _remote_ POIs since they are received from other network participants.

The messages include a nonce (UNIX timestamp), block number, signature (used to derive the sender's on-chain Indexer address) and network. Before saving an entry to the map, the Radio operator verifies through the Graph network subgraph for the sender's on-chain identity and amount of tokens staked, which is used during comparisons later on.

At another interval, the Radio compares the local POIs with the collected remote ones. That interval can be set by the operator, the default currently is 30 seconds. The remote POIs are sorted so that for each subgraph (on each block), the POI that is backed by the most on-chain stake is selected. This means that the combined stake of all Indexers that attested to it is considered, not just the highest staking Indexer. The top POI is then compared with the local POI for that subgraph at that block to determine consensus.

After a successful comparison, the attestations that have been checked are removed from the store.

## Developing the POI Radio

#### Building the image using the Dockerfile locally

If you want to make any changes to the POI Radio codebase, you can use this option.

##### Prerequisites

1. Clone this repo and `cd` into it
2. Create a `.env` file that includes at least the required environment variables. To see the full list of environment variables you can provide, check out the [Configuration](#configuration) section.

##### Running the POI Radio inside a Docker container

```bash
docker-compose up -d
```

### Building POI Radio locally

To have full control over the POI Radio code and run it directly on your machine (without Docker) you can use this option.

#### Prerequisites

1. Clone this repo and `cd` into it
2. Make sure you have the following installed:

- [Rust](https://www.rust-lang.org/tools/install)
- [Go](https://go.dev/doc/install)
- Build tools (e.g. the `build-essentials` package for Debian-based Linux distributions or [Xcode Command Line Tools](https://mac.install.guide/commandlinetools/index.html) for MacOS)
- C compiler (e.g. the `clang` package for Debian-based Linux distribution or [Xcode Command Line Tools](https://mac.install.guide/commandlinetools/index.html) for MacOS)
- OpenSSL (e.g. the `libssl-dev` package for Debian-based Linux distribution or `openssl` for MacOS)
- PostreSQL libraries and headers (e.g. the `libpq-dev` package for Debian-based Linux distribution or `postgresql` for MacOS)

3. You have **Graph Node** syncing your indexer's on-chain allocations.
4. You have created a `.env` file that includes at least the required environment variables. To see the full list of environment variables you can provide, check out the [Configuration](#configuration) section.

#### Running the POI Radio natively

```
cargo run
```